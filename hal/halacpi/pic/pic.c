
/* INCLUDES *******************************************************************/

#include <hal.h>
#include "pic.h"

//#define NDEBUG
#include <debug.h>

/* GLOBALS ********************************************************************/

/* This table basically keeps track of level vs edge triggered interrupts.
   Windows has 250+ entries, but it seems stupid to replicate that since the PIC
   can't actually have that many.

   When a level interrupt is registered, the respective pointer in this table is
   modified to point to a dimiss routine for level interrupts instead.

   The other thing this table does is special case IRQ7, IRQ13 and IRQ15:

   - If an IRQ line is deasserted before it is acknowledged due to a noise spike
     generated by an expansion device (since the IRQ line is low during the 1st
     acknowledge bus cycle), the i8259 will keep the line low for at least 100ns
     When the spike passes, a pull-up resistor will return the IRQ line to high.
     Since the PIC requires the input be high until the first acknowledge, the
     i8259 knows that this was a spurious interrupt, and on the second interrupt
     acknowledge cycle, it reports this to the CPU. Since no valid interrupt has
     actually happened Intel hardcoded the chip to report IRQ7 on the master PIC
     and IRQ15 on the slave PIC (IR7 either way).

     "ISA System Architecture", 3rd Edition, states that these cases should be
     handled by reading the respective Interrupt Service Request (ISR) bits from
     the affected PIC, and validate whether or not IR7 is set. If it isn't, then
     the interrupt is spurious and should be ignored.

     Note that for a spurious IRQ15, we DO have to send an EOI to the master for
     IRQ2 since the line was asserted by the slave when it received the spurious
     IRQ15!

   - When the 80287/80387 math co-processor generates an FPU/NPX trap, this is
     connected to IRQ13, so we have to clear the busy latch on the NPX port.
*/
PHAL_DISMISS_INTERRUPT HalpSpecialDismissTable[16] =
{
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrq07,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrqGeneric,
    HalpDismissIrq13,
    HalpDismissIrqGeneric,
    HalpDismissIrq15
};

/* These are the level IRQ dismissal functions that get copied in the table
   above if the given IRQ is actually level triggered.
*/
PHAL_DISMISS_INTERRUPT HalpSpecialDismissLevelTable[16] =
{
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrq07Level,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrqLevel,
    HalpDismissIrq13Level,
    HalpDismissIrqLevel,
    HalpDismissIrq15Level
};

/* This table contains the static x86 PIC mapping between IRQLs and IRQs */
ULONG KiI8259MaskTable[32] =
{
#if defined(__GNUC__) || defined(__clang__) || (defined(_MSC_VER) && _MSC_VER >= 1900)
    /* It Device IRQLs only start at 4 or higher, so these are just software
       IRQLs that don't really change anything on the hardware
    */
    0b00000000000000000000000000000000, /* IRQL 0 */
    0b00000000000000000000000000000000, /* IRQL 1 */
    0b00000000000000000000000000000000, /* IRQL 2 */
    0b00000000000000000000000000000000, /* IRQL 3 */

    /* These next IRQLs are actually useless from the PIC perspective, because
       with only 2 PICs, the mask you can send them is only 8 bits each, for 16
       bits total, so these IRQLs are masking off a phantom PIC.
    */
    0b11111111100000000000000000000000, /* IRQL 4 */
    0b11111111110000000000000000000000, /* IRQL 5 */
    0b11111111111000000000000000000000, /* IRQL 6 */
    0b11111111111100000000000000000000, /* IRQL 7 */
    0b11111111111110000000000000000000, /* IRQL 8 */
    0b11111111111111000000000000000000, /* IRQL 9 */
    0b11111111111111100000000000000000, /* IRQL 10 */
    0b11111111111111110000000000000000, /* IRQL 11 */

    /* Okay, now we're finally starting to mask off IRQs on the slave PIC, from
       IRQ15 to IRQ8. This means the higher-level IRQs get less priority in the
       IRQL sense.
    */
    0b11111111111111111000000000000000, /* IRQL 12 */
    0b11111111111111111100000000000000, /* IRQL 13 */
    0b11111111111111111110000000000000, /* IRQL 14 */
    0b11111111111111111111000000000000, /* IRQL 15 */
    0b11111111111111111111100000000000, /* IRQL 16 */
    0b11111111111111111111110000000000, /* IRQL 17 */
    0b11111111111111111111111000000000, /* IRQL 18 */
    0b11111111111111111111111000000000, /* IRQL 19 */

    /* Now we mask off the IRQs on the master. Notice the 0 "droplet"? You might
       have also seen that IRQL 18 and 19 are essentially equal as far as the
       PIC is concerned. That bit is actually IRQ8, which happens to be the RTC.
       The RTC will keep firing as long as we don't reach PROFILE_LEVEL which
       actually kills it. The RTC clock (unlike the system clock) is used by the
       profiling APIs in the HAL, so that explains the logic.
    */
    0b11111111111111111111111010000000, /* IRQL 20 */
    0b11111111111111111111111011000000, /* IRQL 21 */
    0b11111111111111111111111011100000, /* IRQL 22 */
    0b11111111111111111111111011110000, /* IRQL 23 */
    0b11111111111111111111111011111000, /* IRQL 24 */
    0b11111111111111111111111011111000, /* IRQL 25 */
    0b11111111111111111111111011111010, /* IRQL 26 */
    0b11111111111111111111111111111010, /* IRQL 27 */

    /* IRQL 24 and 25 are actually identical, so IRQL 28 is actually the last
       IRQL to modify a bit on the master PIC. It happens to modify the very
       last of the IRQs, IRQ0, which corresponds to the system clock interval
       timer that keeps track of time (the Windows heartbeat). We only want to
       turn this off at a high-enough IRQL, which is why IRQLs 24 and 25 are the
       same to give this guy a chance to come up higher. Note that IRQL 28 is
       called CLOCK2_LEVEL, which explains the usage we just explained.
    */
    0b11111111111111111111111111111011, /* IRQL 28 */

    /* We have finished off with the PIC so there's nothing left to mask at the
       level of these IRQLs, making them only logical IRQLs on x86 machines.
       Note that we have another 0 "droplet" you might've caught since IRQL 26.
       In this case, it's the 2nd bit that never gets turned off, which is IRQ2,
       the cascade IRQ that we use to bridge the slave PIC with the master PIC.
       We never want to turn it off, so no matter the IRQL, it will be set to 0.
    */
    0b11111111111111111111111111111011, /* IRQL 29 */
    0b11111111111111111111111111111011, /* IRQL 30 */
    0b11111111111111111111111111111011  /* IRQL 31 */
#else
    0,                             /* IRQL 0 */
    0,                             /* IRQL 1 */
    0,                             /* IRQL 2 */
    0,                             /* IRQL 3 */
    0xFF800000,                    /* IRQL 4 */
    0xFFC00000,                    /* IRQL 5 */
    0xFFE00000,                    /* IRQL 6 */
    0xFFF00000,                    /* IRQL 7 */
    0xFFF80000,                    /* IRQL 8 */
    0xFFFC0000,                    /* IRQL 9 */
    0xFFFE0000,                    /* IRQL 10 */
    0xFFFF0000,                    /* IRQL 11 */
    0xFFFF8000,                    /* IRQL 12 */
    0xFFFFC000,                    /* IRQL 13 */
    0xFFFFE000,                    /* IRQL 14 */
    0xFFFFF000,                    /* IRQL 15 */
    0xFFFFF800,                    /* IRQL 16 */
    0xFFFFFC00,                    /* IRQL 17 */
    0xFFFFFE00,                    /* IRQL 18 */
    0xFFFFFE00,                    /* IRQL 19 */
    0xFFFFFE80,                    /* IRQL 20 */
    0xFFFFFEC0,                    /* IRQL 21 */
    0xFFFFFEE0,                    /* IRQL 22 */
    0xFFFFFEF0,                    /* IRQL 23 */
    0xFFFFFEF8,                    /* IRQL 24 */
    0xFFFFFEF8,                    /* IRQL 25 */
    0xFFFFFEFA,                    /* IRQL 26 */
    0xFFFFFFFA,                    /* IRQL 27 */
    0xFFFFFFFB,                    /* IRQL 28 */
    0xFFFFFFFB,                    /* IRQL 29 */
    0xFFFFFFFB,                    /* IRQL 30 */
    0xFFFFFFFB                     /* IRQL 31 */
#endif
};

extern ULONG HalpBusType;

/* IRQL MANAGEMENT ************************************************************/

KIRQL
NTAPI
KeGetCurrentIrql(VOID)
{
    /* Return the IRQL */
    return KeGetPcr()->Irql;
}

KIRQL
FASTCALL
KfRaiseIrql(IN KIRQL NewIrql)
{
    PKPCR Pcr = KeGetPcr();
    KIRQL CurrentIrql;

    /* Read current IRQL */
    CurrentIrql = Pcr->Irql;

#if DBG
    /* Validate correct raise */
    if (CurrentIrql > NewIrql)
    {
        /* Crash system */
        Pcr->Irql = PASSIVE_LEVEL;
        KeBugCheck(IRQL_NOT_GREATER_OR_EQUAL);
    }
#endif

    /* Set new IRQL */
    Pcr->Irql = NewIrql;

    /* Return old IRQL */
    return CurrentIrql;
}

/* EDGE INTERRUPT DISMISSAL FUNCTIONS *****************************************/

FORCEINLINE
BOOLEAN
_HalpDismissIrqGeneric(IN KIRQL Irql,
                       IN ULONG Irq,
                       OUT PKIRQL OldIrql)
{
    PIC_MASK Mask;
    KIRQL CurrentIrql;
    I8259_OCW2 Ocw2;
    PKPCR Pcr = KeGetPcr();

    /* First save current IRQL and compare it to the requested one */
    CurrentIrql = Pcr->Irql;

    /* Check if this interrupt is really allowed to happen */
    if (Irql > CurrentIrql)
    {
        /* Set the new IRQL and return the current one */
        Pcr->Irql = Irql;
        *OldIrql = CurrentIrql;

        /* Prepare OCW2 for EOI */
        Ocw2.Bits = 0;
        Ocw2.EoiMode = SpecificEoi;

        /* Check which PIC needs the EOI */
        if (Irq >= 8)
        {
            /* Send the EOI for the IRQ */
            WRITE_PORT_UCHAR(PIC2_CONTROL_PORT, Ocw2.Bits | ((Irq - 8) & 0xFF));

            /* Send the EOI for IRQ2 on the master because this was cascaded */
            WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw2.Bits | 2);
        }
        else
        {
            /* Send the EOI for the IRQ */
            WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw2.Bits | (Irq &0xFF));
        }

        /* Enable interrupts and return success */
        _enable();
        return TRUE;
    }

    /* Update the IRR so that we deliver this interrupt when the IRQL is proper */
    Pcr->IRR |= (1 << (Irq + 4));
    //DPRINT1("_HalpDismissIrqGeneric: Irql - %X, Pcr->IRR - %X\n", Irql, Pcr->IRR);

    /* Set new PIC mask to real IRQL level, since the optimization is lost now */
    Mask.Both = (KiI8259MaskTable[CurrentIrql] | Pcr->IDR) & 0xFFFF;
    WRITE_PORT_UCHAR(PIC1_DATA_PORT, Mask.Master);
    WRITE_PORT_UCHAR(PIC2_DATA_PORT, Mask.Slave);

    /* Now lie and say this was spurious */
    return FALSE;
}

BOOLEAN
NTAPI
HalpDismissIrqGeneric(IN KIRQL Irql,
                      IN ULONG Irq,
                      OUT PKIRQL OldIrql)
{
    /* Run the inline code */
    return _HalpDismissIrqGeneric(Irql, Irq, OldIrql);
}

BOOLEAN
NTAPI
HalpDismissIrq07(IN KIRQL Irql,
                 IN ULONG Irq,
                 OUT PKIRQL OldIrql)
{
    I8259_OCW3 Ocw3;
    I8259_ISR Isr;

    /* Request the ISR */
    Ocw3.Bits = 0;
    Ocw3.Sbo = 1;
    Ocw3.ReadRequest = ReadIsr;
    WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw3.Bits);

    /* Read the ISR */
    Isr.Bits = READ_PORT_UCHAR(PIC1_CONTROL_PORT);

    /* Is IRQ 7 really active? If it isn't, this is spurious so fail */
    if (Isr.Irq7 == FALSE)
        return FALSE;

    /* Do normal interrupt dismiss */
    return _HalpDismissIrqGeneric(Irql, Irq, OldIrql);
}

BOOLEAN
NTAPI
HalpDismissIrq13(IN KIRQL Irql,
                 IN ULONG Irq,
                 OUT PKIRQL OldIrql)
{
    /* Clear the FPU busy latch */
    WRITE_PORT_UCHAR((PUCHAR)0x00F0, 0);

    /* Do normal interrupt dismiss */
    return _HalpDismissIrqGeneric(Irql, Irq, OldIrql);
}

BOOLEAN
NTAPI
HalpDismissIrq15(IN KIRQL Irql,
                 IN ULONG Irq,
                 OUT PKIRQL OldIrql)
{
    I8259_OCW3 Ocw3;
    I8259_OCW2 Ocw2;
    I8259_ISR Isr;

    /* Request the ISR */
    Ocw3.Bits = 0;
    Ocw3.Sbo = 1; /* This encodes an OCW3 vs. an OCW2 */
    Ocw3.ReadRequest = ReadIsr;
    WRITE_PORT_UCHAR(PIC2_CONTROL_PORT, Ocw3.Bits);

    /* Read the ISR */
    Isr.Bits = READ_PORT_UCHAR(PIC2_CONTROL_PORT);

    /* Is IRQ15 really active (this is IR7) */
    if (Isr.Irq7 == FALSE)
    {
        /* It isn't, so we have to EOI IRQ2 because this was cascaded */
        Ocw2.Bits = 0;
        Ocw2.EoiMode = SpecificEoi;
        WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw2.Bits | 2);

        /* And now fail since this was spurious */
        return FALSE;
    }

    /* Do normal interrupt dismiss */
    return _HalpDismissIrqGeneric(Irql, Irq, OldIrql);
}

/* LEVEL INTERRUPT DISMISSAL FUNCTIONS ****************************************/

FORCEINLINE
BOOLEAN
_HalpDismissIrqLevel(IN KIRQL Irql,
                     IN ULONG Irq,
                     OUT PKIRQL OldIrql)
{
    PIC_MASK Mask;
    KIRQL CurrentIrql;
    I8259_OCW2 Ocw2;
    PKPCR Pcr = KeGetPcr();

    /* Update the PIC */
    Mask.Both = (KiI8259MaskTable[Irql] | Pcr->IDR) & 0xFFFF;
    WRITE_PORT_UCHAR(PIC1_DATA_PORT, Mask.Master);
    WRITE_PORT_UCHAR(PIC2_DATA_PORT, Mask.Slave);

    /* Update the IRR so that we clear this interrupt when the IRQL is proper */
    Pcr->IRR |= (1 << (Irq + 4));

    /* Save current IRQL */
    CurrentIrql = Pcr->Irql;

    /* Prepare OCW2 for EOI */
    Ocw2.Bits = 0;
    Ocw2.EoiMode = SpecificEoi;

    /* Check which PIC needs the EOI */
    if (Irq >= 8)
    {
        /* Send the EOI for the IRQ */
        WRITE_PORT_UCHAR(PIC2_CONTROL_PORT, Ocw2.Bits | ((Irq - 8) & 0xFF));

        /* Send the EOI for IRQ2 on the master because this was cascaded */
        WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw2.Bits | 2);
    }
    else
    {
        /* Send the EOI for the IRQ */
        WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw2.Bits | (Irq & 0xFF));
    }

    /* Check if this interrupt should be allowed to happen */
    if (Irql > CurrentIrql)
    {
        /* Set the new IRQL and return the current one */
        Pcr->Irql = Irql;
        *OldIrql = CurrentIrql;

        /* Enable interrupts and return success */
        _enable();
        return TRUE;
    }

    /* Now lie and say this was spurious */
    return FALSE;
}

BOOLEAN
NTAPI
HalpDismissIrqLevel(IN KIRQL Irql,
                    IN ULONG Irq,
                    OUT PKIRQL OldIrql)
{
    /* Run the inline code */
    return _HalpDismissIrqLevel(Irql, Irq, OldIrql);
}

BOOLEAN
NTAPI
HalpDismissIrq07Level(IN KIRQL Irql,
                      IN ULONG Irq,
                      OUT PKIRQL OldIrql)
{
    I8259_OCW3 Ocw3;
    I8259_ISR Isr;

    /* Request the ISR */
    Ocw3.Bits = 0;
    Ocw3.Sbo = 1;
    Ocw3.ReadRequest = ReadIsr;
    WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw3.Bits);

    /* Read the ISR */
    Isr.Bits = READ_PORT_UCHAR(PIC1_CONTROL_PORT);

    /* Is IRQ 7 really active? If it isn't, this is spurious so fail */
    if (Isr.Irq7 == FALSE)
        return FALSE;

    /* Do normal interrupt dismiss */
    return _HalpDismissIrqLevel(Irql, Irq, OldIrql);
}

BOOLEAN
NTAPI
HalpDismissIrq13Level(IN KIRQL Irql,
                      IN ULONG Irq,
                      OUT PKIRQL OldIrql)
{
    /* Clear the FPU busy latch */
    WRITE_PORT_UCHAR((PUCHAR)0x00F0, 0);

    /* Do normal interrupt dismiss */
    return _HalpDismissIrqLevel(Irql, Irq, OldIrql);
}

BOOLEAN
NTAPI
HalpDismissIrq15Level(IN KIRQL Irql,
                      IN ULONG Irq,
                      OUT PKIRQL OldIrql)
{
    I8259_OCW3 Ocw3;
    I8259_OCW2 Ocw2;
    I8259_ISR Isr;

    /* Request the ISR */
    Ocw3.Bits = 0;
    Ocw3.Sbo = 1; /* This encodes an OCW3 vs. an OCW2 */
    Ocw3.ReadRequest = ReadIsr;
    WRITE_PORT_UCHAR(PIC2_CONTROL_PORT, Ocw3.Bits);

    /* Read the ISR */
    Isr.Bits = READ_PORT_UCHAR(PIC2_CONTROL_PORT);

    /* Is IRQ15 really active (this is IR7) */
    if (Isr.Irq7 == FALSE)
    {
        /* It isn't, so we have to EOI IRQ2 because this was cascaded */
        Ocw2.Bits = 0;
        Ocw2.EoiMode = SpecificEoi;
        WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Ocw2.Bits | 2);

        /* And now fail since this was spurious */
        return FALSE;
    }

    /* Do normal interrupt dismiss */
    return _HalpDismissIrqLevel(Irql, Irq, OldIrql);
}

/* FUNCTIONS ******************************************************************/

VOID
NTAPI
HalpInitializeLegacyPICs(BOOLEAN InterruptMode)
{
    I8259_ICW1 Icw1;
    I8259_ICW2 Icw2;
    I8259_ICW3 Icw3;
    I8259_ICW4 Icw4;

    ASSERT(!(__readeflags() & EFLAGS_INTERRUPT_MASK));

    /* Initialize ICW1 for master, interval 8 */
    Icw1.NeedIcw4 = TRUE;
    Icw1.OperatingMode = Cascade;
    Icw1.Interval = Interval8;
    //Icw1.InterruptMode = EdgeTriggered;
    Icw1.InterruptMode = InterruptMode ? LevelTriggered : EdgeTriggered;
    Icw1.Init = TRUE;
    Icw1.InterruptVectorAddress = 0;
    WRITE_PORT_UCHAR(PIC1_CONTROL_PORT, Icw1.Bits);

    /* ICW2 - interrupt vector offset */
    Icw2.Bits = PRIMARY_VECTOR_BASE;
    WRITE_PORT_UCHAR(PIC1_DATA_PORT, Icw2.Bits);

    /* Connect slave to IRQ 2 */
    Icw3.Bits = 0;
    Icw3.SlaveIrq2 = TRUE;
    WRITE_PORT_UCHAR(PIC1_DATA_PORT, Icw3.Bits);

    /* Enable 8086 mode, non-automatic EOI, non-buffered mode, non special fully nested mode */
    Icw4.SystemMode = New8086Mode;
    Icw4.EoiMode = NormalEoi;
    Icw4.BufferedMode = NonBuffered;
    Icw4.SpecialFullyNestedMode = FALSE;
    Icw4.Reserved = 0;
    WRITE_PORT_UCHAR(PIC1_DATA_PORT, Icw4.Bits);

    /* Mask all interrupts */
    WRITE_PORT_UCHAR(PIC1_DATA_PORT, 0xFF);

    /* Initialize ICW1 for slave, interval 8 */
    Icw1.NeedIcw4 = TRUE;
    //Icw1.InterruptMode = EdgeTriggered;
    Icw1.InterruptMode = InterruptMode ? LevelTriggered : EdgeTriggered;
    Icw1.OperatingMode = Cascade;
    Icw1.Interval = Interval8;
    Icw1.Init = TRUE;
    Icw1.InterruptVectorAddress = 0; /* This is only used in MCS80/85 mode */
    WRITE_PORT_UCHAR(PIC2_CONTROL_PORT, Icw1.Bits);

    /* Set interrupt vector base */
    Icw2.Bits = PRIMARY_VECTOR_BASE + 8;
    WRITE_PORT_UCHAR(PIC2_DATA_PORT, Icw2.Bits);

    /* Slave ID */
    Icw3.Bits = 0;
    Icw3.SlaveId = 2;
    WRITE_PORT_UCHAR(PIC2_DATA_PORT, Icw3.Bits);

    /* Enable 8086 mode, non-automatic EOI, non-buffered mode, non special fully nested mode */
    Icw4.SystemMode = New8086Mode;
    Icw4.EoiMode = NormalEoi;
    Icw4.BufferedMode = NonBuffered;
    Icw4.SpecialFullyNestedMode = FALSE;
    Icw4.Reserved = 0;
    WRITE_PORT_UCHAR(PIC2_DATA_PORT, Icw4.Bits);

    /* Mask all interrupts */
    WRITE_PORT_UCHAR(PIC2_DATA_PORT, 0xFF);
}

VOID
NTAPI
HalpInitializePICs(IN BOOLEAN EnableInterrupts)
{
    ULONG EFlags;
    BOOLEAN InterruptMode = FALSE; // EdgeTriggered

    DPRINT1("HalpInitializePICs: EnableInterrupts - %X\n", EnableInterrupts);

    /* Save EFlags and disable interrupts */
    EFlags = __readeflags();
    _disable();

    if (HalpBusType & 2)
    {
        DPRINT1("HalpInitializePICs: HalpBusType - %X\n", HalpBusType);
         ASSERT(0);//DbgBreakPoint();
        //InterruptMode = TRUE; // LevelTriggered
    }

    DPRINT1("HalpInitializePICs: InterruptMode - %X\n", InterruptMode);

    /* Initialize and mask the PIC */
    HalpInitializeLegacyPICs(InterruptMode);

    /* Restore interrupt state */
    if (EnableInterrupts)
        EFlags |= EFLAGS_INTERRUPT_MASK;

    __writeeflags(EFlags);
}

/* PUBLIC FUNCTIONS **********************************************************/

BOOLEAN
NTAPI
HalBeginSystemInterrupt(IN KIRQL Irql,
                        IN ULONG Vector,
                        OUT PKIRQL OldIrql)
{
    UNIMPLEMENTED;
    ASSERT(0);//HalpDbgBreakPointEx();
    return FALSE;
}

VOID
FASTCALL
HalClearSoftwareInterrupt(IN KIRQL Irql)
{
    /* Mask out the requested bit */
    KeGetPcr()->IRR &= ~(1 << Irql);
}

VOID
NTAPI
HalDisableSystemInterrupt(IN ULONG Vector,
                          IN KIRQL Irql)
{
    UNIMPLEMENTED;
    ASSERT(0);//HalpDbgBreakPointEx();
}

BOOLEAN
NTAPI
HalEnableSystemInterrupt(IN ULONG Vector,
                         IN KIRQL Irql,
                         IN KINTERRUPT_MODE InterruptMode)
{
    UNIMPLEMENTED;
    ASSERT(0);//HalpDbgBreakPointEx();
    return FALSE;
}

/* NT use nonstandard parameters calling */
VOID
NTAPI
HalEndSystemInterrupt(_In_ KIRQL Irql,
                      _In_ PKTRAP_FRAME TrapFrame)
{
    UNIMPLEMENTED;
    ASSERT(0);//HalpDbgBreakPointEx();
}

VOID
FASTCALL
HalRequestSoftwareInterrupt(IN KIRQL Irql)
{
    UNIMPLEMENTED;
    ASSERT(0);//HalpDbgBreakPointEx();
}

VOID
FASTCALL
KfLowerIrql(IN KIRQL OldIrql)
{
    UNIMPLEMENTED;
    ASSERT(0);//HalpDbgBreakPointEx();
}

KIRQL
NTAPI
KeRaiseIrqlToDpcLevel(VOID)
{
    PKPCR Pcr = KeGetPcr();
    KIRQL CurrentIrql;

    /* Save and update IRQL */
    CurrentIrql = Pcr->Irql;
    Pcr->Irql = DISPATCH_LEVEL;

#if DBG
    /* Validate correct raise */
    if (CurrentIrql > DISPATCH_LEVEL)
        KeBugCheck(IRQL_NOT_GREATER_OR_EQUAL);
#endif

    /* Return the previous value */
    return CurrentIrql;
}

KIRQL
NTAPI
KeRaiseIrqlToSynchLevel(VOID)
{
    PKPCR Pcr = KeGetPcr();
    KIRQL CurrentIrql;

    /* Save and update IRQL */
    CurrentIrql = Pcr->Irql;
    Pcr->Irql = SYNCH_LEVEL;

#if DBG
    /* Validate correct raise */
    if (CurrentIrql > SYNCH_LEVEL)
    {
        /* Crash system */
        KeBugCheckEx(IRQL_NOT_GREATER_OR_EQUAL,
                     CurrentIrql,
                     SYNCH_LEVEL,
                     0,
                     1);
    }
#endif

    /* Return the previous value */
    return CurrentIrql;
}

/* EOF */
